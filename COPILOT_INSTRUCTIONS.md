# GitHub Copilot Instructions for Signals Monorepo

This document provides guidelines for using GitHub Copilot effectively within the Signals monorepo. Adhering to these instructions will ensure consistency, maintainability, and high-quality code.

## 1. General Principles

*   **Understand Before Accepting**: Always review Copilot's suggestions carefully. Do not blindly accept code. Ensure you understand what the code does and that it aligns with the project's requirements and existing logic.
*   **Context is Key**: Copilot performs best when given clear and concise context. Use descriptive variable names, meaningful function signatures, and relevant comments to guide its suggestions.
*   **Iterative Refinement**: Treat Copilot's suggestions as a starting point. Refine and adapt the generated code to fit the specific needs of the task, ensuring it integrates seamlessly with the surrounding codebase.
*   **Testing**: All generated code, like any other code, must be covered by appropriate tests (unit, integration, end-to-end).

## 2. Code Style and Formatting

*   **Adhere to Prettier/ESLint**: The project uses Prettier for code formatting and ESLint for linting. Ensure your IDE is configured to use these tools. Copilot's suggestions should generally conform, but always run formatters and linters before committing.
*   **Naming Conventions**: Follow established naming conventions for variables, functions, classes, and files (e.g., `camelCase` for variables, `PascalCase` for classes, `kebab-case` for file names).
*   **TypeScript First**: Prefer TypeScript for new code. Copilot is proficient with TypeScript, and type hints will improve its suggestions.

## 3. Specific Guidelines

### a. NX Monorepo Structure

*   **Project Boundaries**: Be mindful of NX project boundaries. Copilot might suggest imports or code that violates these boundaries. Ensure all dependencies are correctly declared in `project.json` files.
*   **Generators**: When creating new components, services, or modules, prefer using NX generators (`nx g <plugin>:<generator>`) over manual creation. Copilot can assist in filling out the generated files.

### b. GCP and Cloud Functions

*   **Service Accounts and IAM**: When dealing with GCP interactions, ensure Copilot suggests secure practices, such as using service accounts with least privilege and proper IAM roles.
*   **Environment Variables**: Sensitive information should be accessed via environment variables (e.g., `process.env.GCP_PROJECT_ID`) and managed through Secret Manager, not hardcoded.
*   **Logging and Monitoring**: Encourage Copilot to include appropriate logging and error handling using GCP's logging and monitoring services.

### c. AI Agents and Orchestration

*   **Tool Definitions**: When defining new tools for agents, ensure they are clearly described and follow the existing `tools.ts` pattern.
*   **Orchestration Logic**: For the Gemini Orchestrator, ensure Copilot's suggestions align with the state machine or workflow patterns used for agent coordination.

## 4. Tagging AI-Generated Code

To facilitate review and understanding, all significant blocks of code primarily generated by GitHub Copilot (more than 5-10 lines) should be tagged with a comment:

```typescript
// AI-GENERATED: [Brief description of what Copilot generated]
// Example: AI-GENERATED: Initial boilerplate for BigQuery query function
function exampleFunction() {
  // ... Copilot generated code ...
}
```

This helps in identifying sections that might require closer human scrutiny or different review processes.

## 5. Feedback and Improvement

*   **Provide Feedback**: Use the built-in feedback mechanisms in your IDE to provide feedback to GitHub Copilot. This helps improve its suggestions over time.
*   **Share Best Practices**: If you discover effective prompting techniques or common pitfalls, share them with the team to improve collective efficiency.

## Document Owner

This document is owned by `garretnelson368@gmail.com`.
