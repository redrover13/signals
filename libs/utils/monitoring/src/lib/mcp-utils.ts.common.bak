/**
 * Utility functions for Model Context Protocol (MCP) servers
 */

export interface McpServerConfig {
  name: string;
  enabled: boolean;
  endpoint: string;
  auth?: {
    type: 'none' | 'apikey' | 'oauth';
    key?: string;
    token?: string;
  };
  timeoutMs?: number;
  retries?: number;
  tools?: string[];
  modelContext?: Record<string, any>;
}

export interface McpMetrics {
  serverCount: number;
  healthyServers: number;
  requestCount: number;
  successCount: number;
  failureCount: number;
  avgResponseTimeMs: number;
  p95ResponseTimeMs: number;
  p99ResponseTimeMs: number;
  timeWindow: {
    start: string;
    end: string;
  };
}

/**
 * Format MCP metrics for logging and monitoring
 * @param metrics MCP metrics object
 * @returns Formatted metrics string
 */
export function formatMcpMetrics(metrics: McpMetrics): string {
  if (!metrics) {
    return 'No metrics available';
  }
  
  return `
MCP Metrics:
-----------
Servers: ${metrics?.serverCount || 0} (${metrics?.healthyServers || 0} healthy)
Requests: ${metrics?.requestCount || 0} (${metrics?.successCount || 0} success, ${metrics?.failureCount || 0} failures)
Response Times: 
  - Avg: ${metrics?.avgResponseTimeMs || 0}ms
  - P95: ${metrics?.p95ResponseTimeMs || 0}ms
  - P99: ${metrics?.p99ResponseTimeMs || 0}ms
Time Window: ${metrics?.timeWindow?.start || 'N/A'} to ${metrics?.timeWindow?.end || 'N/A'}
`;
}

/**
 * Safely parse a JSON string into an object
 * @param jsonStr JSON string to parse
 * @param defaultValue Default value to return if parsing fails
 * @returns Parsed object or default value
 */
export function safeJsonParse<T>(jsonStr: string | null | undefined, defaultValue: T): T {
  if (!jsonStr) {
    return defaultValue;
  }
  
  try {
    return JSON.parse(jsonStr) as T;
  } catch (err) {
    console.error('Error parsing JSON:', err);
    return defaultValue;
  }
}

/**
 * Create a standardized health check for MCP servers
 * @param config MCP server configuration
 * @returns Promise resolving to a health check result
 */
export async function checkMcpServerHealth(config: McpServerConfig): Promise<boolean> {
  if (!config || !config.enabled || !config.endpoint) {
    return false;
  }
  
  try {
    const response = await fetch(`${config.endpoint}/health`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...(config.auth?.type === 'apikey' && config.auth.key 
          ? { 'Authorization': `Bearer ${config.auth.key}` } 
          : {})
      },
      timeout: config.timeoutMs || 5000
    });
    
    return response.ok;
  } catch (err) {
    console.error(`Health check failed for MCP server ${config.name}:`, err);
    return false;
  }
}

/**
 * Calculate metrics for MCP server configuration
 * @param config MCP configuration with multiple servers
 * @returns MCP metrics object
 */
export function calculateMcpMetrics(config: { servers?: McpServerConfig[] }): McpMetrics {
  const metrics: McpMetrics = {
    serverCount: 0,
    healthyServers: 0,
    requestCount: 0,
    successCount: 0,
    failureCount: 0,
    avgResponseTimeMs: 0,
    p95ResponseTimeMs: 0,
    p99ResponseTimeMs: 0,
    timeWindow: {
      start: new Date(Date.now() - 3600000).toISOString(), // Last hour
      end: new Date().toISOString()
    }
  };
  
  if (config?.servers) {
    config.servers.forEach((server, index) => {
      if (server.enabled) {
        metrics.serverCount++;
        // We'd need to actually check health in a real implementation
        // For now, we'll simulate some healthy servers
        if (index % 3 !== 0) { // Arbitrary condition for demo
          metrics.healthyServers++;
        }
      }
    });
  }
  
  const enabledServers = config?.servers ? config.servers.filter(s => s && s.enabled) : [];
  metrics.serverCount = enabledServers.length;
  
  // Sample data for demonstration
  metrics.requestCount = 1250;
  metrics.successCount = 1180;
  metrics.failureCount = 70;
  metrics.avgResponseTimeMs = 234;
  metrics.p95ResponseTimeMs = 456;
  metrics.p99ResponseTimeMs = 789;
  
  return metrics;
}
