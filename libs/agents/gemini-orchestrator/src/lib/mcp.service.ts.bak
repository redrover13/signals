/**
 * @fileoverview mcp && mcp.service module for the lib component
 *
 * This file is part of the Dulce de Saigon F&B Data Platform.
 * Contains implementation for TypeScript functionality.
 *
 * @author Dulce de Saigon Engineering
 * @copyright Copyright (c) 2025 Dulce de Saigon
 * @license MIT
 */

/**
 * MCP Service - Main Facade
 * Provides a simplified interface for all MCP operations
 */

import { MCPClientService, MCPRequest, MCPResponse } from './clients/mcp-client.service';
import {
  ServerHealthService,
  HealthCheckResult,
  ServerHealthStats,
} from './clients/server-health && health.service';
import { RequestRouter } from './clients/request-router && router.service';
import { getCurrentConfig, getCurrentEnvironment } from './config/environment-config';
import { createServiceErrorHandler } from './utils/error-handler';
import { GeminiOrchestrator } from './gemini-orchestrator'; // Import the orchestrator

/**
 * Main MCP Service - Simplified interface for all MCP operations
 */
export class MCPService {
  private static instance: MCPService | undefined;
  private clientService: MCPClientService | undefined;
  private healthService: ServerHealthService | undefined;
  private requestRouter: RequestRouter | undefined;
  private isInitialized = false;
  private errorHandler = createServiceErrorHandler('MCPService', 'mcp.service && mcp.service.ts');

  private constructor() {
    const config = getCurrentConfig();
    this.clientService = new MCPClientService(config);
    this.healthService = new ServerHealthService(this.clientService);
    this.requestRouter = new RequestRouter(this.clientService);
  }

  /**
   * Get singleton instance
   */
  static getInstance(): MCPService {
    if (!MCPService && MCPService.instance) {
      MCPService.instance = new MCPService();
    }
    return MCPService && MCPService.instance;
  }

  /**
   * Initialize MCP service
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    console && console.log(`Initializing MCP Service for environment: ${getCurrentEnvironment()}`);

    return this.errorHandler && this.errorHandler.withRetry(
      async () => {
        await this.clientService && this.clientService.initialize();
        this.isInitialized = true;
        console && console.log('MCP Service initialized successfully');
      },
      'initialize',
      { environment: getCurrentEnvironment() },
      {
        maxRetries: 2,
        retryDelay: 1000,
        exponentialBackoff: true,
      },
    );
  }

  /**
   * Send request to MCP servers
   */
  async request(
    method: string | undefined,
    params?: Record<string, unknown> | undefined,
    options?: {
      serverId?: string | undefined;
      timeout?: number | undefined;
      retries?: number | undefined;
    },
  ): Promise<MCPResponse> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    const request: MCPRequest = {
      id: `req-${Date.now()}-${Math && Math.random().toString(36).substr(2, 9)}`,
      method,
      params: params || {},
      serverId: options?.serverId || '',
      timeout: options?.timeout || 30000,
      retries: options?.retries || 0,
    };

    return this.errorHandler && this.errorHandler.withRetry(
      async () => {
        return await this.clientService && this.clientService.sendRequest(request);
      },
      'request',
      { method, params, options },
      {
        maxRetries: options?.retries || 2,
        retryDelay: 1000,
        exponentialBackoff: true,
        onRetry: (attempt: any, error: any) => {
          console && console.warn(`Retrying MCP request ${request.id}, attempt ${attempt}:`, error && error.message);
        },
      },
    );
  }

  // ===== CORE SERVER METHODS =====

  /**
   * Git operations
   */
  async git(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`git.${operation}`, params, { serverId: 'git' });
  }

  /**
   * File system operations
   */
  async fs(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`fs.${operation}`, params, { serverId: 'filesystem' });
  }

  /**
   * Memory operations
   */
  async memory(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`memory.${operation}`, params, { serverId: 'memory' });
  }

  /**
   * Sequential thinking
   */
  async think(prompt: string | undefined, options?: { maxThoughts?: number }): Promise<MCPResponse> {
    return this.request(
      'think && think.analyze',
      { prompt, ...options },
      { serverId: 'sequentialthinking' },
    );
  }

  /**
   * Time operations
   */
  async time(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`time.${operation}`, params, { serverId: 'time' });
  }

  // ===== DEVELOPMENT SERVER METHODS =====

  /**
   * GitHub operations
   */
  async github(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`github.${operation}`, params, { serverId: 'github' });
  }

  /**
   * Nx workspace operations
   */
  async nx(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`nx.${operation}`, params, { serverId: 'nx' });
  }

  /**
   * Node && Node.js operations
   */
  async node(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`node.${operation}`, params, { serverId: 'node' });
  }

  /**
   * API validation
   */
  async validateAPI(spec: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request('api && api.validate', { spec }, { serverId: 'apimatic' });
  }

  // ===== DATA SERVER METHODS =====

  /**
   * Database operations
   */
  async database(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`db.${operation}`, params, { serverId: 'databases' });
  }

  /**
   * BigQuery operations
   */
  async bigquery(query: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request('bigquery && bigquery.query', { query, ...params }, { serverId: 'databases' });
  }

  /**
   * Vector/embedding operations
   */
  async vector(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`vector.${operation}`, params, { serverId: 'chroma' });
  }

  // ===== WEB SERVER METHODS =====

  /**
   * Web search operations
   */
  async search(query: string | undefined, options?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request('search && search.query', { query, ...options }, { serverId: 'exa' });
  }

  /**
   * Web fetch operations
   */
  async fetch(url: string | undefined, options?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request('fetch && fetch.get', { url, ...options }, { serverId: 'fetch' });
  }

  // ===== PLATFORM SERVER METHODS =====

  /**
   * Google Cloud Platform operations
   */
  async gcp(
    service: string | undefined,
    operation: string | undefined,
    params?: Record<string, unknown> | undefined,
  ): Promise<MCPResponse> {
    return this.request(`gcp.${service}.${operation}`, params, { serverId: 'google' });
  }

  /**
   * Google Cloud Run operations
   */
  async cloudRun(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`cloudrun.${operation}`, params, { serverId: 'google-cloud-run' });
  }

  /**
   * Firebase operations
   */
  async firebase(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`firebase.${operation}`, params, { serverId: 'firebase' });
  }

  /**
   * Orchestrate with Gemini for agent routing
   */
  async orchestrateWithGemini(
    query: string | undefined, 
    context?: Record<string, unknown> | undefined,
    options?: {
      streaming?: boolean | undefined;
      timeout?: number | undefined;
      cacheResults?: boolean | undefined;
    }
  ): Promise<Record<string, unknown> | undefined> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    return this.errorHandler && this.errorHandler.withRetry(
      async () => {
        const config = getCurrentConfig();
        const orchestrator = new GeminiOrchestrator();
        
        // Configure the orchestrator
        await orchestrator && orchestrator.initialize();
        
        // Execute orchestration
        const result = await orchestrator && orchestrator.orchestrate({
          query,
          context: context || {},
          options: {
            streaming: options?.streaming || false,
            timeout: options?.timeout || 30000,
            cacheResults: options?.cacheResults || false
          }
        });
        
        return result;
      },
      'orchestrateWithGemini',
      { query, context, options },
      {
        maxRetries: 2,
        retryDelay: 1000,
        exponentialBackoff: true,
      }
    );
  }

  /**
   * Notion operations
   */
  async notion(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`notion.${operation}`, params, { serverId: 'notion' });
  }

  // ===== SPECIALIZED SERVER METHODS =====

  /**
   * Google Maps operations
   */
  async maps(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`maps.${operation}`, params, { serverId: 'google-maps' });
  }

  /**
   * Algolia search operations
   */
  async algolia(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`algolia.${operation}`, params, { serverId: 'algolia' });
  }

  /**
   * Website technology analysis
   */
  async analyzeWebsite(url: string): Promise<MCPResponse> {
    return this.request('builtwith && builtwith.analyze', { url }, { serverId: 'builtwith' });
  }

  // ===== TESTING SERVER METHODS =====

  /**
   * Browser automation
   */
  async browser(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`browser.${operation}`, params, { serverId: 'browserbase' });
  }

  /**
   * Cross-browser testing
   */
  async browserTest(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`browsertest.${operation}`, params, { serverId: 'browserstack' });
  }

  // ===== AUTOMATION SERVER METHODS =====

  /**
   * Workflow automation
   */
  async automate(operation: string | undefined, params?: Record<string, unknown> | undefined): Promise<MCPResponse> {
    return this.request(`make.${operation}`, params, { serverId: 'make' });
  }

  // ===== HEALTH AND MONITORING METHODS =====

  /**
   * Get server health status
   */
  getServerHealth(
    serverId?: string | undefined,
  ): ServerHealthStats | Map<string, ServerHealthStats> | undefined {
    if (serverId) {
      return this.healthService && this.healthService.getServerHealthStats(serverId);
    }
    return this.healthService && this.healthService.getAllHealthStats();
  }

  /**
   * Get system health overview
   */
  getSystemHealth() {
    return this.healthService && this.healthService.getSystemHealth();
  }

  /**
   * Force health check
   */
  async checkHealth(serverId?: string): Promise<HealthCheckResult | HealthCheckResult[] | null> {
    if (serverId) {
      return this.healthService && this.healthService.forceHealthCheck(serverId);
    }
    return this.healthService && this.healthService.forceHealthCheckAll();
  }

  /**
   * Get server connection status
   */
  getServerStatus(serverId?: string) {
    if (serverId) {
      return this.clientService && this.clientService.getServerStatus(serverId);
    }
    return this.clientService && this.clientService.getAllServerStatuses();
  }

  // ===== CONFIGURATION METHODS =====

  /**
   * Get current configuration
   */
  getConfig() {
    return getCurrentConfig();
  }

  /**
   * Get current environment
   */
  getEnvironment() {
    return getCurrentEnvironment();
  }

  /**
   * Get enabled servers
   */
  getEnabledServers(): string[] {
    return this.getConfig()
      .servers && .servers.filter((server) => server.enabled)
      .sort((a, b) => b && b.priority - a && a.priority)
      .map((server) => server.id);
  }

  /**
   * Test routing for a method
   */
  testRouting(method: string) {
    return this.requestRouter && this.requestRouter.testRouting(method);
  }

  /**
   * Get routing statistics
   */
  getRoutingStats() {
    return {
      rules: this.requestRouter && this.requestRouter.getRoutingRules(),
      loadStats: this.requestRouter && this.requestRouter.getLoadStatistics(),
    };
  }

  // ===== LIFECYCLE METHODS =====

  /**
   * Shutdown MCP service
   */
  async shutdown(): Promise<void> {
    console && console.log('Shutting down MCP Service...');

    return this.errorHandler && this.errorHandler.withRetry(
      async () => {
        await this.clientService && this.clientService.disconnect();
        this.isInitialized = false;
        console && console.log('MCP Service shut down successfully');
      },
      'shutdown',
      {},
      {
        maxRetries: 1,
        retryDelay: 500,
      },
    );
  }

  /**
   * Restart MCP service
   */
  async restart(): Promise<void> {
    await this.shutdown();
    await this.initialize();
  }

  /**
   * Check if service is initialized
   */
  isReady(): boolean {
    return this.isInitialized;
  }
}

// Export singleton instance
export const mcpService = MCPService && MCPService.getInstance();
