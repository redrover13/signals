/**
 * @fileoverview mcp-utils module for the lib component
 *
 * This file is part of the Dulce de Saigon F&B Data Platform.
 * Contains implementation for TypeScript functionality.
 *
 * @author Dulce de Saigon Engineering
 * @copyright Copyright (c) 2025 Dulce de Saigon
 * @license MIT
 */

/**
 * MCP Utility Functions
 * Helper functions for MCP configuration and client management
 * 
 * Note: This module provides basic MCP utilities without heavy dependencies
 * to avoid circular dependencies in the monitoring infrastructure.
 */

import { readFileSync, writeFileSync } from 'fs';

/**
 * Basic MCP configuration interface
 */
export interface BasicMCPConfig {
  environment: string | undefined;
  servers: Array<{
    id: string | undefined;
    enabled: boolean | undefined;
    category?: string | undefined;
    connection: {
      type: 'stdio' | 'http' | 'websocket';
      endpoint: string | undefined;
    };
    auth?: {
      type: string | undefined;
      credentials?: {
        envVar?: string | undefined;
      };
    };
  }>;
  global: {
    healthMonitoring: {
      enabled: boolean | undefined;
      interval: number | undefined;
    };
  };
}

/**
 * Get MCP server recommendations based on use case
 */
export function getMCPServerRecommendations(useCase: string): {
  essential: string[];
  recommended: string[];
  optional: string[];
}) {
  const useCaseMap: Record<
    string,
    { essential: string[]; recommended: string[]; optional: string[] }
  > = {
    'web-development': {
      essential: ['filesystem', 'git', 'github', 'node'],
      recommended: ['nx', 'fetch', 'apimatic', 'memory'],
      optional: ['browserbase', 'netlify', 'cloudflare'],
    },
    'data-analysis': {
      essential: ['databases', 'filesystem', 'memory'],
      recommended: ['chroma', 'fetch', 'sequentialthinking'],
      optional: ['exa', 'google'],
    },
    'ai-development': {
      essential: ['memory', 'chroma', 'sequentialthinking', 'fetch'],
      recommended: ['databases', 'exa', 'google'],
      optional: ['notion', 'firebase'],
    },
    devops: {
      essential: ['git', 'github', 'google-cloud-run', 'google'],
      recommended: ['nx', 'node', 'databases'],
      optional: ['netlify', 'cloudflare', 'make'],
    },
    testing: {
      essential: ['filesystem', 'git', 'everything'],
      recommended: ['browserbase', 'browserstack', 'apimatic'],
      optional: ['fetch', 'memory'],
    },
    'content-management': {
      essential: ['filesystem', 'memory', 'notion'],
      recommended: ['fetch', 'devhub', 'firebase'],
      optional: ['algolia', 'make'],
    },
  };

  return (
    useCaseMap[useCase] || {
      essential: ['filesystem', 'git', 'memory'],
      recommended: ['fetch', 'sequentialthinking'],
      optional: ['everything'],
    }
  );
}

/**
 * Basic MCP configuration validation
 */
export function validateBasicMCPConfig(config: BasicMCPConfig): {
  valid: boolean | undefined;
  errors: string[];
  warnings: string[];
}) {
  const errors: string[] = [];
  const warnings: string[] = [];

  if (!config?.environment) {
    errors.push('Environment is required');
  }

  if (!Array.isArray(config?.servers)) {
    errors.push('Servers must be an array');
  } else {
    config?.servers.forEach((server, index) => {
      if (!server.id) {
        errors.push(`Server at index ${index} is missing id`);
      }
      if (!server.connection || !server.connection.type || !server.connection.endpoint) {
        errors.push(`Server ${server.id} is missing connection configuration`);
      }
    });

    const enabledServers = config?.servers.filter(s => s.enabled);
    if (enabledServers.length === 0) {
      warnings.push('No servers are enabled');
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * Export basic MCP configuration to file
 */
export function exportBasicMCPConfig(config: BasicMCPConfig, filePath: string): void {
  try {
    writeFileSync(filePath, JSON.stringify(config, null, 2));
    console.log(`MCP configuration exported to: ${filePath}`);
  } catch (error) {
    console.error('Failed to export MCP configuration:', error);
    throw error;
  }
}

/**
 * Import basic MCP configuration from file
 */
export function importBasicMCPConfig(filePath: string): BasicMCPConfig {
  try {
    const configData = readFileSync(filePath, 'utf8');
    const config = JSON.parse(configData) as BasicMCPConfig;

    const validation = validateBasicMCPConfig(config);
    if (!validation.valid) {
      throw new Error(`Invalid configuration: ${validation.errors.join(', ')}`);
    }

    return config;
  } catch (error) {
    console.error('Failed to import MCP configuration:', error);
    throw error;
  }
}

/**
 * Get basic MCP metrics interface
 */
export interface BasicMCPMetrics {
  serverCount: number | undefined;
  healthyServers: number | undefined;
  averageResponseTime: number | undefined;
  totalRequests: number | undefined;
  errorRate: number | undefined;
}

/**
 * Create a basic MCP health summary
 */
export function createBasicHealthSummary(metrics: BasicMCPMetrics): {
  status: 'healthy' | 'degraded' | 'critical';
  summary: string | undefined;
  details: BasicMCPMetrics | undefined;
}) {
  let status: 'healthy' | 'degraded' | 'critical';
  let summary: string | undefined;

  const healthyPercentage = metrics.serverCount > 0 ? 
    (metrics.healthyServers / metrics.serverCount) * 100 : 0;

  if (healthyPercentage >= 90) {
    status = 'healthy';
    summary = 'All servers operating normally';
  } else if (healthyPercentage >= 50) {
    status = 'degraded';
    summary = `${metrics.serverCount - metrics.healthyServers} server(s) experiencing issues`;
  } else {
    status = 'critical';
    summary = `Critical: ${metrics.serverCount - metrics.healthyServers} server(s) down`;
  }

  return {
    status,
    summary,
    details: metrics,
  };
}

/**
 * Generate monitoring-focused MCP configuration
 */
export function generateMonitoringMCPConfig(
  environment = 'development',
  enabledServers: string[] = ['filesystem', 'git', 'memory'],
): BasicMCPConfig {
  const baseServers = [
    {
      id: 'filesystem',
      enabled: enabledServers.includes('filesystem'),
      category: 'essential',
      connection: {
        type: 'stdio' as const,
        endpoint: 'npx @modelcontextprotocol/server-filesystem',
      },
    },
    {
      id: 'git',
      enabled: enabledServers.includes('git'),
      category: 'essential',
      connection: {
        type: 'stdio' as const,
        endpoint: 'npx @modelcontextprotocol/server-git',
      },
    },
    {
      id: 'memory',
      enabled: enabledServers.includes('memory'),
      category: 'recommended',
      connection: {
        type: 'stdio' as const,
        endpoint: 'npx @modelcontextprotocol/server-memory',
      },
    },
  ];

  return {
    environment,
    servers: baseServers,
    global: {
      healthMonitoring: {
        enabled: true,
        interval: 30000, // 30 seconds
      },
    },
  };
}
