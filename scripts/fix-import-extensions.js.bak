#!/usr/bin/env node

/**
 * Import File Extension Fixer
 * 
 * This script adds proper file extensions to import statements in ES Module files.
 * In ES Modules mode, Node.js requires explicit file extensions in import paths.
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// ES Modules specific: Get __dirname equivalent
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Get root directory
const rootDir = path.resolve(__dirname, '..');

// ANSI color codes for formatting
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m'
};

// Process command line arguments
const args = process.argv.slice(2);
const dryRun = args.includes('--dry-run');
const fixAll = args.includes('--fix-all');
const verbose = args.includes('--verbose');
const targetFile = args.find(arg => !arg.startsWith('--'));

// Tracked stats
let totalImports = 0;
let missingExtensions = 0;
let fixedImports = 0;
let errorCount = 0;

/**
 * Print a section header
 */
function printHeader(text) {
  console.log(`\n${colors.bright}${colors.cyan}=== ${text} ===${colors.reset}\n`);
}

/**
 * Print an info line
 */
function printInfo(label, value, color = colors.green) {
  console.log(`${colors.bright}${label}:${colors.reset} ${color}${value}${colors.reset}`);
}

/**
 * Print a warning
 */
function printWarning(text) {
  console.log(`${colors.yellow}⚠ WARNING: ${text}${colors.reset}`);
}

/**
 * Print an error
 */
function printError(text) {
  console.log(`${colors.red}❌ ERROR: ${text}${colors.reset}`);
}

/**
 * Print a success message
 */
function printSuccess(text) {
  console.log(`${colors.green}✓ ${text}${colors.reset}`);
}

/**
 * Find all ES Module files in the project
 */
function findESModuleFiles() {
  try {
    const esModuleGrepCmd = `find ${rootDir} -type f -name "*.js" -o -name "*.ts" -not -path "*/node_modules/*" -not -path "*/dist/*" | xargs grep -l "import \\\\|export " 2>/dev/null || true`;
    return execSync(esModuleGrepCmd).toString().trim().split('\n').filter(Boolean);
  } catch (error) {
    printError(`Failed to find ES Module files: ${error.message}`);
    return [];
  }
}

/**
 * Check if a module path is a relative import that might need an extension
 */
function isRelativeImport(importPath) {
  return importPath.startsWith('./') || importPath.startsWith('../') || importPath === '.';
}

/**
 * Check if an import already has a file extension
 */
function hasFileExtension(importPath) {
  const extensions = ['.js', '.mjs', '.cjs', '.jsx', '.ts', '.mts', '.cts', '.tsx', '.json'];
  return extensions.some(ext => importPath.endsWith(ext));
}

/**
 * Get appropriate extension for an import based on source file
 */
function getAppropriateExtension(importPath, filePath) {
  const baseDir = path.dirname(filePath);
  const absoluteImportPath = path.resolve(baseDir, importPath);
  
  // Check for TypeScript files first, which should use .js at runtime
  const tsExtensions = ['.ts', '.tsx', '.mts'];
  for (const ext of tsExtensions) {
    if (fs.existsSync(`${absoluteImportPath}${ext}`)) {
      return '.js'; // TypeScript files become .js at runtime
    }
  }
  
  // Check for JavaScript files
  const jsExtensions = ['.js', '.jsx', '.mjs'];
  for (const ext of jsExtensions) {
    if (fs.existsSync(`${absoluteImportPath}${ext}`)) {
      return ext;
    }
  }
  
  // Check for JSON files
  if (fs.existsSync(`${absoluteImportPath}.json`)) {
    return '.json';
  }
  
  // Check if it's a directory with an index file
  for (const ext of [...tsExtensions, ...jsExtensions]) {
    if (fs.existsSync(path.join(absoluteImportPath, `index${ext}`))) {
      return '/index.js'; // TypeScript index files become index.js at runtime
    }
  }
  
  // No matching file found
  return null;
}

/**
 * Fix import statements in a file
 */
function fixFileImports(filePath) {
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let modified = false;
    
    // Use regex to find import statements
    const importRegex = /import\s+(?:(?:[\w*\s{},]*)\s+from\s+)?['"](\.\.?\/[^'"]+)['"]/g;
    let match;
    let fileImports = 0;
    let fileMissing = 0;
    let fileFixed = 0;
    
    // Collect all imports that need to be fixed
    const importsToFix = [];
    while ((match = importRegex.exec(content)) !== null) {
      fileImports++;
      totalImports++;
      
      const importPath = match[1];
      if (isRelativeImport(importPath) && !hasFileExtension(importPath)) {
        fileMissing++;
        missingExtensions++;
        
        const extension = getAppropriateExtension(importPath, filePath);
        if (extension) {
          importsToFix.push({
            importPath,
            newPath: `${importPath}${extension}`,
            matchIndex: match.index,
            matchLength: match[0].length
          });
        } else {
          if (verbose) {
            printWarning(`Could not determine extension for import: ${importPath} in ${filePath}`);
          }
        }
      }
    }
    
    // Apply fixes in reverse order to maintain correct indices
    importsToFix.sort((a, b) => b.matchIndex - a.matchIndex);
    
    for (const fix of importsToFix) {
      const before = content.substring(0, fix.matchIndex);
      const importStatement = content.substring(fix.matchIndex, fix.matchIndex + fix.matchLength);
      const after = content.substring(fix.matchIndex + fix.matchLength);
      
      // Replace the import path
      const newImportStatement = importStatement.replace(
        `'${fix.importPath}'`, 
        `'${fix.newPath}'`
      ).replace(
        `"${fix.importPath}"`, 
        `"${fix.newPath}"`
      );
      
      content = before + newImportStatement + after;
      fileFixed++;
      fixedImports++;
      modified = true;
    }
    
    if (fileImports > 0 && verbose) {
      printInfo(`${path.basename(filePath)}`, `${fileImports} imports, ${fileMissing} missing extensions, ${fileFixed} fixed`, 
        fileMissing > 0 ? (fileFixed > 0 ? colors.yellow : colors.red) : colors.green);
    }
    
    if (modified && !dryRun) {
      fs.writeFileSync(filePath, content, 'utf8');
      printSuccess(`Fixed ${fileFixed} imports in ${filePath}`);
    } else if (modified && dryRun) {
      printInfo(`Would fix`, `${fileFixed} imports in ${filePath}`, colors.cyan);
    }
    
    return modified;
  } catch (error) {
    printError(`Failed to fix imports in ${filePath}: ${error.message}`);
    errorCount++;
    return false;
  }
}

/**
 * Process a batch of files
 */
function processFiles(files) {
  printHeader('Processing Files');
  
  let fixedFiles = 0;
  
  for (const filePath of files) {
    const modified = fixFileImports(filePath);
    if (modified) fixedFiles++;
  }
  
  printHeader('Summary');
  printInfo('Total Files Processed', files.length, colors.cyan);
  printInfo('Files Modified', fixedFiles, colors.green);
  printInfo('Total Imports Scanned', totalImports, colors.cyan);
  printInfo('Imports Missing Extensions', missingExtensions, missingExtensions > 0 ? colors.yellow : colors.green);
  printInfo('Imports Fixed', fixedImports, colors.green);
  
  if (errorCount > 0) {
    printInfo('Errors', errorCount, colors.red);
  }
  
  if (dryRun) {
    printInfo('Dry Run', 'No changes were actually made', colors.yellow);
  }
}

/**
 * Print usage information
 */
function printUsage() {
  console.log(`
${colors.bright}Import File Extension Fixer${colors.reset}

This script adds proper file extensions to import statements in ES Module files.
In ES Modules mode, Node.js requires explicit file extensions in import paths.

Usage:
  node ${path.basename(__filename)} [options] [filepath]

Options:
  --dry-run      Show what would be changed without making changes
  --fix-all      Process all ES Module files in the project
  --verbose      Show detailed information about processing

Examples:
  node ${path.basename(__filename)} --dry-run            # Scan and report only
  node ${path.basename(__filename)} --fix-all            # Fix all ES Module files
  node ${path.basename(__filename)} path/to/file.js      # Process a single file
  `);
}

/**
 * Main function
 */
function main() {
  // Show usage if help is requested
  if (args.includes('--help') || args.includes('-h')) {
    printUsage();
    return;
  }
  
  console.log(`${colors.bright}${colors.magenta}Import File Extension Fixer${colors.reset}`);
  
  if (dryRun) {
    console.log(`${colors.yellow}DRY RUN MODE: No files will be modified${colors.reset}`);
  }
  
  // Process a single target file if specified
  if (targetFile) {
    if (!fs.existsSync(targetFile)) {
      printError(`File not found: ${targetFile}`);
      process.exit(1);
    }
    
    processFiles([targetFile]);
    return;
  }
  
  // Process all ES Module files if requested
  if (fixAll) {
    const files = findESModuleFiles();
    if (files.length === 0) {
      printWarning('No ES Module files found');
      return;
    }
    
    printInfo('Found', `${files.length} ES Module files`, colors.cyan);
    processFiles(files);
  } else {
    console.log(`\n${colors.yellow}No action taken. Use --fix-all to process all files or specify a single file.${colors.reset}`);
    console.log(`${colors.yellow}Use --help for more information.${colors.reset}`);
  }
}

// Run the main function
main();
