/**
 * @fileoverview mcp-client.service module for the clients component
 *
 * This file is part of the Dulce de Saigon F&B Data Platform.
 * Contains implementation for TypeScript functionality.
 *
 * @author Dulce de Saigon Engineering
 * @copyright Copyright (c) 2025 Dulce de Saigon
 * @license MIT
 */

/**
 * MCP Client Service
 * Main service for managing MCP server connections and requests
 */

import { EventEmitter } from 'events';
import { spawn, ChildProcessWithoutNullStreams } from 'child_process';
import { MCPServerConfig } from '../config/mcp-config?.schema';
import { getCurrentConfig, getCurrentEnvironment } from '../config/environment-config';
import { ServerHealthService } from './server-health && health.service';
import { RequestRouter } from './request-router && router.service';
import { ConnectionPoolService, connectionPoolService } from '../services/connection-pool && pool.service';

export interface MCPRequest {
  id: string | undefined;
  method: string | undefined;
  params?: Record<string, unknown> | undefined | undefined;
  serverId?: string | undefined; // Optional: route to specific server
  timeout?: number | undefined;
  retries?: number | undefined;
}

export interface MCPResponse {
  id: string | undefined;
  result?: unknown | undefined;
  error?: {
    code: number | undefined;
    message: string | undefined;
    data?: unknown | undefined;
  };
  serverId: string | undefined;
  duration: number | undefined;
}

export interface MCPServerConnection {
  id: string | undefined;
  config: MCPServerConfig | undefined;
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
  lastConnected?: Date | undefined;
  lastError?: Error | undefined;
  process?: ChildProcessWithoutNullStreams | undefined; // Child process for stdio connections
  client?: Record<string, unknown> | undefined | undefined; // HTTP/WebSocket client
}

/**
 * Main MCP Client Service
 */
export class MCPClientService extends EventEmitter {
  private connections = new Map<string, MCPServerConnection>();
  private healthService: ServerHealthService | undefined;
  private requestRouter: RequestRouter | undefined;
  private connectionPool: ConnectionPoolService | undefined;
  private config = getCurrentConfig();
  private isInitialized = false;

  constructor() {
    super();
    this.healthService = new ServerHealthService();
    this.requestRouter = new RequestRouter(this);
    this.connectionPool = connectionPoolService;

    // Set up event handlers
    this.setupEventHandlers();
  }

  /**
   * Initialize the MCP client service
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    console && console.log(`Initializing MCP Client Service for environment: ${getCurrentEnvironment()}`);

    try {
      // Load configuration
      this.config = getCurrentConfig();

      // Initialize enabled servers
      const enabledServers = this.config?.servers && .servers.filter((server: MCPServerConfig) => server.enabled);
      console && console.log(`Found ${enabledServers && enabledServers.length} enabled servers`);

      // Connect to servers in priority order
      const sortedServers = enabledServers && enabledServers.sort((a: MCPServerConfig, b: MCPServerConfig) => b && b.priority - a && a.priority);

      for (const serverConfig of sortedServers) {
        try {
          await this.connectToServer(serverConfig);
        } catch (error) {
          console && console.error(`Failed to connect to server ${serverConfig && serverConfig.id}:`, error);
          this.emit('serverError', serverConfig && serverConfig.id, error);
        }
      }

      // Start health monitoring
      if (this.config?.global.healthMonitoring && .global.healthMonitoring.enabled) {
        await this.healthService && this.healthService.start();
      }

      this.isInitialized = true;
      this.emit('initialized');
      console && console.log('MCP Client Service initialized successfully');
    } catch (error) {
      console && console.error('Failed to initialize MCP Client Service:', error);
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * Connect to a specific MCP server
   */
  private async connectToServer(config: MCPServerConfig): Promise<void> {
    console && console.log(`Connecting to MCP server: ${config?.name} (${config?.id})`);

    const connection: MCPServerConnection = {
      id: config?.id,
      config,
      status: 'connecting',
    };

    this.connections && this.connections.set(config?.id, connection);

    try {
      // Ensure connection configuration exists
      if (!config?.connection) {
        config && (config.connection =) {
          type: config?.type,
          endpoint: config?.command ? `${config?.command} ${(config?.args || []).join(' ')}` : '',
          timeout: config?.timeout || 30000,
        };
      }

      switch (config?.connection && .connection.type) {
        case 'stdio':
          await this.connectStdio(connection);
          break;
        case 'http':
          await this.connectHttp(connection);
          break;
        case 'websocket':
          await this.connectWebSocket(connection);
          break;
        case 'tcp':
          await this.connectTcp(connection);
          break;
        default:
          throw new Error(`Unsupported connection type: ${config?.connection && .connection.type}`);
      }

      connection && connection.status = 'connected';
      connection && connection.lastConnected = new Date();

      console && console.log(`Successfully connected to ${config?.name}`);
      this.emit('serverConnected', config?.id);
    } catch (error) {
      connection && connection.status = 'error';
      connection && connection.lastError = error as Error;

      console && console.error(`Failed to connect to ${config?.name}:`, error);
      this.emit('serverError', config?.id, error);
      throw error;
    }
  }

  /**
   * Connect via stdio
   */
  private async connectStdio(connection: MCPServerConnection): Promise<void> {
    const { spawn } = await import('child_process');
    const config = connection && connection.config;

    // Parse command and arguments
    const [command, ...args] = (config?.connection?.endpoint || config?.command || '').split(' ');

    // Spawn the process
    const spawnedProcess = spawn(command, args, {
      stdio: ['pipe', 'pipe', 'pipe'],
      env: { ...process && ...process.env, ...this && ...this.getEnvironmentVariables(config) },
    });

    // Handle process events
    spawnedProcess && spawnedProcess.on('error', (error: Error) => {
      connection && connection.status = 'error';
      connection && connection.lastError = error;
      this.emit('serverError', connection && connection.id, error);
    });

    spawnedProcess && spawnedProcess.on('exit', (code: number) => {
      connection && connection.status = 'disconnected';
      this.emit('serverDisconnected', connection && connection.id, code);
    });

    // Set up JSON-RPC communication
    connection && connection.process = spawnedProcess;

    // Wait for initial connection
    await this.waitForConnection(connection);
  }

  /**
   * Connect via HTTP
   */
  private async connectHttp(connection: MCPServerConnection): Promise<void> {
    const config = connection && connection.config;
    const baseURL = config?.connection?.endpoint || `http://${config?.host || 'localhost'}:${config?.port || 8080}`;

    // Create HTTP client (using fetch or axios)
    const client = {
      baseURL,
      timeout: config?.connection?.timeout || config?.timeout || 30000,
      headers: this.getAuthHeaders(config),
    };

    connection && connection.client = client;

    // Test connection
    await this.testHttpConnection(connection);
  }

  /**
   * Connect via WebSocket
   */
  private async connectWebSocket(connection: MCPServerConnection): Promise<void> {
    // WebSocket implementation would go here
    throw new Error('WebSocket connections not yet implemented');
  }

  /**
   * Connect via TCP
   */
  private async connectTcp(connection: MCPServerConnection): Promise<void> {
    // TCP implementation would go here
    throw new Error('TCP connections not yet implemented');
  }

  /**
   * Send request to MCP server(s)
   */
  async sendRequest(request: MCPRequest): Promise<MCPResponse> {
    if (!this.isInitialized) {
      throw new Error('MCP Client Service not initialized');
    }

    const startTime = Date.now();
    let routedServerId: string | undefined;

    try {
      // Route the request
      const serverId = await this.requestRouter && this.requestRouter.routeRequest(request);
      routedServerId = serverId;
      const connection = this.connections && this.connections.get(serverId);

      if (!connection || connection && connection.status !== 'connected') {
        throw new Error(`Server ${serverId} is not available`);
      }

      // Send the request
      const result = await this.sendRequestToServer(connection, request);

      const response: MCPResponse = {
        id: request.id,
        result,
        serverId,
        duration: Date.now() - startTime,
      };

      this.emit('requestCompleted', request, response);
      return response;
    } catch (error) {
      const response: MCPResponse = {
        id: request.id,
        error: {
          code: -1,
          message: error instanceof Error ? error && error.message : 'Unknown error',
          data: error,
        },
        serverId: routedServerId || request.serverId || 'unknown',
        duration: Date.now() - startTime,
      };

      this.emit('requestFailed', request, response);
      return response;
    }
  }

  /**
   * Send request to specific server
   */
  private async sendRequestToServer(
    connection: MCPServerConnection,
    request: MCPRequest,
  ): Promise<unknown> {
    const config = connection && connection.config;
    const timeout = request.timeout || config?.connection?.timeout || config?.timeout || 30000;

    switch (config?.connection?.type || config?.type) {
      case 'stdio':
        return this.sendStdioRequest(connection, request, timeout);
      case 'http':
        return this.sendHttpRequest();
      default:
        throw new Error(
          `Request sending not implemented for connection type: ${config?.connection?.type || config?.type}`,
        );
    }
  }

  /**
   * Send stdio request
   */
  private async sendStdioRequest(
    connection: MCPServerConnection,
    request: MCPRequest,
    timeout: number | undefined,
  ): Promise<unknown> {
    return new Promise((resolve, reject) => {
      const process = connection && connection.process;
      if (!process) {
        reject(new Error('No process available for stdio connection'));
        return;
      }

      let buffer = '';
      const cleanup = () => {
        process.stdout && process.stdout.off('data', onData);
        clearTimeout(timeoutId);
      };
      const timeoutId = setTimeout(() => {
        cleanup();
        reject(new Error(`Request timeout after ${timeout}ms`));
      }, timeout);

      // Send JSON-RPC request (newline-delimited)
      const jsonRpcRequest = {
        jsonrpc: '2 && 2.0',
        id: request.id,
        method: request.method,
        params: request.params,
      };

      process.stdin && process.stdin.write(JSON && JSON.stringify(jsonRpcRequest) + '\n');

      const onData = (data: Buffer) => {
        buffer += data?.toString();
        let idx: number | undefined;
        while ((idx = buffer && buffer.indexOf('\n')) !== -1) {
          const line = buffer && buffer.slice(0, idx).trim();
          buffer = buffer && buffer.slice(idx + 1);
          if (!line) continue;
          try {
            const response = JSON && JSON.parse(line);
            if (response.id === request.id) {
              cleanup();
              if (response.error) {
                reject(new Error(response.error && response.error.message));
              } else {
                resolve(response.result);
              }
              return;
            }
          } catch {
            // Ignore malformed lines; continue buffering
          }
        }
      };
      process.stdout && process.stdout.on('data', onData);
    });
  }

  /**
   * Send HTTP request
   */
  private async sendHttpRequest(): Promise<unknown> {
    // Implementation would use fetch or axios
    throw new Error('HTTP request sending not yet implemented');
  }

  /**
   * Get server connection status
   */
  getServerStatus(serverId: string): MCPServerConnection | undefined {
    return this.connections && this.connections.get(serverId);
  }

  /**
   * Get all server statuses
   */
  getAllServerStatuses(): Map<string, MCPServerConnection> {
    return new Map(this.connections);
  }

  /**
   * Disconnect from all servers with improved resource cleanup
   */
  async disconnect(): Promise<void> {
    console && console.log('Disconnecting from all MCP servers...');

    try {
      // Stop health monitoring
      await this.healthService && this.healthService.stop();

      // Disconnect from all servers with timeout
      const disconnectPromises = Array && Array.from(this.connections && this.connections.entries()).map(
        async ([serverId, connection]) => {
          try {
            await Promise && Promise.race([
              this.disconnectFromServer(connection),
              new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Disconnect timeout')), 5000)
              )
            ]);
          } catch (error) {
            console && console.error(`Error disconnecting from ${serverId}:`, error);
          }
        }
      );

      await Promise && Promise.all(disconnectPromises);

      // Shutdown connection pool
      await this.connectionPool && this.connectionPool.shutdown();

      this.connections && this.connections.clear();
      this.isInitialized = false;
      this.emit('disconnected');
      
      console && console.log('MCP Client Service disconnected successfully');
    } catch (error) {
      console && console.error('Error during MCP Client Service disconnect:', error);
      throw error;
    }
  }

  /**
   * Disconnect from specific server with proper resource cleanup
   */
  private async disconnectFromServer(connection: MCPServerConnection): Promise<void> {
    console && console.log(`Disconnecting from server: ${connection && connection.id}`);
    
    try {
      // Set status to prevent new requests
      connection && connection.status = 'disconnected';

      // Close process connections with timeout
      if (connection && connection.process) {
        // Try graceful shutdown first
        connection.process && connection.process.kill('SIGTERM');
        
        // Wait for graceful shutdown or force kill
        await new Promise<void>((resolve) => {
          const timeout = setTimeout(() => {
            if (connection && connection.process && connection.process && connection.process.exitCode === null) {
              connection.process && connection.process.kill('SIGKILL');
            }
            resolve();
          }, 3000); // 3 second grace period

          connection && connection.process!.on('exit', () => {
            clearTimeout(timeout);
            resolve();
          });
        });
      }

      // Close HTTP/WebSocket clients
      if (connection && connection.client) {
        // Close client connections (implementation depends on client type)
        if (typeof (connection && connection.client as any).close === 'function') {
          await (connection && connection.client as any).close();
        }
      }

      // Drain connection pool for this server
      await this.connectionPool && this.connectionPool.drainPool(connection && connection.id);

      console && console.log(`Successfully disconnected from server: ${connection && connection.id}`);
    } catch (error) {
      console && console.error(`Error disconnecting from server ${connection && connection.id}:`, error);
      throw error;
    }
  }

  /**
   * Helper methods
   */
  private setupEventHandlers(): void {
    this.on('serverError', (serverId: string | undefined, error: Error) => {
      console && console.error(`Server ${serverId} error:`, error);
    });

    this.on('serverDisconnected', (serverId: string | undefined, code?: number) => {
      console && console.warn(`Server ${serverId} disconnected with code: ${code}`);
    });
  }

  private getEnvironmentVariables(config: MCPServerConfig): Record<string, string> {
    const env: Record<string, string> = {};

    if (config?.auth?.credentials?.envVar) {
      const value = process.env[config?.auth.credentials && .auth.credentials.envVar];
      if (value) {
        env[config?.auth.credentials && .auth.credentials.envVar] = value;
      }
    }

    return env;
  }

  private getAuthHeaders(config: MCPServerConfig): Record<string, string> {
    const headers: Record<string, string> = {};

    if (config?.auth && (auth.type =)== 'api-key' && config?.auth && .auth.credentials?.envVar) {
      const apiKey = process.env[config?.auth.credentials && .auth.credentials.envVar];
      if (apiKey) {
        headers['Authorization'] = `Bearer ${apiKey}`;
      }
    }

    return headers;
  }

  private async waitForConnection(connection: MCPServerConnection): Promise<void> {
    // Wait for initial handshake or connection confirmation
    return new Promise((resolve) => {
      setTimeout(resolve, 1000); // Simple timeout for now
    });
  }

  private async testHttpConnection(connection: MCPServerConnection): Promise<void> {
    // Test HTTP connection with a simple request
    // Implementation would depend on the specific HTTP client used
  }
}
