# Signals Monorepo Best Practices

This document outlines the best practices for developing within the Signals monorepo. Adhering to these guidelines ensures code quality, consistency, maintainability, and efficient collaboration.

## 1. General Development Practices

### a. Code Clarity and Readability

*   **Self-Documenting Code**: Write code that is easy to understand without excessive comments. Use clear variable names, well-named functions, and logical structures.
*   **Comments**: Use comments sparingly, primarily to explain *why* a piece of code exists or *what* a complex algorithm does, rather than *how* it works (which should be evident from the code itself).
*   **Consistency**: Follow existing code patterns and styles within the project. Consistency is more important than personal preference.

### b. Modularity and Reusability

*   **Single Responsibility Principle**: Each module, class, or function should have one clear responsibility.
*   **DRY (Don't Repeat Yourself)**: Avoid duplicating code. Extract common logic into reusable functions or libraries.
*   **Small Functions**: Keep functions small and focused. This improves readability, testability, and reusability.

### c. Error Handling

*   **Graceful Degradation**: Design systems to fail gracefully. Anticipate potential errors and provide appropriate fallback mechanisms.
*   **Meaningful Errors**: Throw descriptive errors with sufficient context to aid debugging.
*   **Centralized Logging**: Utilize the project's centralized logging solution (e.g., GCP Logging) for all application logs.

## 2. NX Monorepo Specifics

### a. Project Structure and Boundaries

*   **Strict Boundaries**: Respect the defined NX project boundaries. Applications should only depend on libraries they explicitly need, and libraries should not have circular dependencies.
*   **Tags and Scopes**: Utilize NX tags (`scope:`, `type:`) in `project.json` files to enforce architectural constraints and improve graph visualization.
*   **Generators**: Use NX generators (`nx g`) to create new applications, libraries, and components. This ensures consistency and proper configuration within the monorepo.

### b. Dependency Management

*   **Explicit Dependencies**: All dependencies must be explicitly declared in the `package.json` of the respective application or library.
*   **Avoid Hoisting Issues**: Be aware of `pnpm`'s strict hoisting. If a dependency is not found, ensure it's correctly listed in the `package.json` of the project that directly uses it.

## 3. AI-Assisted Development

### a. Human vs. AI Code

*   **Human Oversight**: AI-generated code is a tool, not a replacement for human judgment. Always review, understand, and validate code generated by AI tools.
*   **Refinement**: AI tools may generate boilerplate or common patterns. Focus your efforts on refining the logic, ensuring it meets specific business requirements, and integrating it seamlessly.
*   **Tagging**: Follow the guidelines in `COPILOT_INSTRUCTIONS.md` for tagging AI-generated code. This helps in code reviews and understanding the origin of code sections.

### b. Prompt Engineering

*   **Clear Prompts**: Provide clear, concise, and specific prompts to AI tools. The quality of the output directly correlates with the quality of the input.
*   **Iterative Prompting**: Break down complex tasks into smaller, manageable steps and use iterative prompting to guide the AI towards the desired solution.
*   **Contextual Information**: Provide relevant contextual information (e.g., existing code, desired output format, constraints) to improve the AI's understanding.

## 4. Testing Strategy

### a. Test Pyramid

*   **Unit Tests**: Focus on testing individual functions or components in isolation. They should be fast and numerous.
*   **Integration Tests**: Verify the interaction between different components or services.
*   **End-to-End (E2E) Tests**: Test the entire system from a user's perspective. These are typically slower and fewer.

### b. Test Quality

*   **Meaningful Assertions**: Write tests that assert specific behaviors and outcomes.
*   **Readable Tests**: Tests should be as readable as the production code, clearly indicating what is being tested.
*   **Test Coverage**: Aim for high test coverage, but prioritize meaningful tests over simply increasing a percentage.
*   **Test Tagging**: Utilize Jest's `--test-tag` or similar features to categorize and run specific sets of tests (e.g., unit, integration, e2e, slow, fast). This helps in focused testing during development and CI/CD.

## 5. Security and Compliance

*   **Least Privilege**: Design systems and configure IAM roles with the principle of least privilege.
*   **Secret Management**: All sensitive information (API keys, credentials) must be stored and accessed securely via Google Secret Manager.
*   **Static Analysis**: Integrate static code analysis tools (SAST) into the CI/CD pipeline to identify potential security vulnerabilities early.
*   **Dependency Scanning**: Regularly scan third-party dependencies for known vulnerabilities.

## 6. Documentation

*   **Living Documentation**: Keep documentation up-to-date with the codebase. Outdated documentation is often worse than no documentation.
*   **READMEs**: Each application and library should have a clear `README.md` explaining its purpose, how to set it up, and how to run tests.
*   **Architectural Decisions**: Document significant architectural decisions and their rationale.

## Document Owner

This document is owned by `garretnelson368@gmail.com`.
