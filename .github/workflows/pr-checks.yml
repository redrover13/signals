name: Pull Request Checks

on:
  pull_request:
    types: [opened, synchronize, reopened]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Prevent large files
  file-size-check:
    name: File Size Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for large files
        run: |
          # Find files larger than 1MB
          large_files=$(find . -type f -size +1M | grep -v "^./.git" | grep -v "node_modules" || true)
          if [ -n "$large_files" ]; then
            echo "❌ Large files detected (>1MB):"
            echo "$large_files"
            echo "Consider using Git LFS or external storage for these files."
            exit 1
          fi

  # Label PR based on changes
  label:
    name: Auto Label PR
    runs-on: ubuntu-latest
    permissions: 
      contents: read
      pull-requests: write
    steps:
      - uses: actions/labeler@v4
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"

  # Check PR title follows conventional commits
  pr-title:
    name: Validate PR Title
    runs-on: ubuntu-latest
    steps:
      - uses: amannn/action-semantic-pull-request@v5
        env: 
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\
        with:
          types: |
            feat
            fix
            docs
            style
            refactor
            perf
            test
            build
            ci
            chore
            revert
          requireScope: false
          subjectPattern: ^(?![A-Z]).+$
          subjectPatternError: |
            The subject "{subject}" found in the pull request title "{title}"
            didn't match the configured pattern. Please ensure that the subject
            doesn't start with an uppercase character.$LVTXBec49977e7185bc8cc568a584fa14e16766b1e57eced5dc69ee0f1d8ed887bdf System.Text.RegularExpressions.CaptureCollection.get_Count()
						
		} catch (SecurityException) {
			_stack.Clear();
		}
	}

	// This routine is designed to be used in place of IsBaseOf() but should be much cheaper to calculate.
	// false will be returned if either type is not resolved, IsBaseOf() will be called in that event.
	internal static bool IsInstanceOfType(System.Type match, System.Type type) {
		if (type == null || match == null) {
			throw new ArgumentNullException(type == null ? "type" : "match");
		}
		if (match == type) {
			return true;
		}
		if (type.IsInterface || !match.IsClass) {
			return (false);
		}

		// Try to look directly from the type.
		if (type.IsAssignableFrom(match)) {
			return true;
		}
		if (IsNonPublicAssignableFrom(type, match)) { 
			return true;
		}
		return (IsAssignableFrom(match, Type.GetType(type.FullName, false)) || match.IsAssignableFrom(type));
	}

	private static bool IsNonPublicAssignableFrom(System.Type match, System.Type type) {
		if (type == null || match == null) {
			throw new ArgumentNullException(type == null ? "type" : "match");
		}

		// If match is not visible but type and structure allow isbaseof, return true. 
		if (!type.IsVisible && match.BaseType == type) 
			return true;
		if (!type.IsVisible && match == typeof(Object)) 
			return true;

		if (API != null && (!type.IsVisible && API.CanCastTo(type, match))){
			return true;
		}
		return false;
	}

	// This method is more in-depth than the previous, but can throw an exception on either type parameter.
	// false will be returned if either type is not resolved.
	internal static bool IsInstanceOfTypeSimple(System.Type match, System.Type type) {
		if (type == null || match == null) {
			throw new ArgumentNullException(type == null ? "type" : "match");
		}
		if (match == type) {
			return true;
		}
		if (type.IsInterface || !match.IsClass) {
			return (false);
		}
		if (type.IsAssignableFrom(match) || IsNonPublicAssignableFrom(type, match)) {
			return true;
		}
		return IsAssignableFromDirectly(match, Type.GetType(type.FullName, false));
	}

	// Get a method (static or instance) while circumventing the access-check if possible.
	// This is a more performant version of typeof(System.Type).GetMethod(name).
	public static System.Reflection.MethodInfo GetMethodRefl(System.Type type, string name) {
		if (type == null || name == null) {
			throw new ArgumentNullException(type == null ? "type" : "name");
		}

		if (!type.IsInterface) {
			System.Reflection.MethodInfo mi =  type.GetMethod(name);
			if (mi != null)
				return mi;
		}

		foreach (System.Type interfaceType in type.GetInterfaces()) {
			System.Reflection.MethodInfo mi =  interfaceType.GetMethod(name);
			if (mi != null)--/
			return mi;
		}
		return null;
	}

	// Do a member search similar to typeof(System.Type).GetMember(name, Reflection.MemberType.Method, BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance), but
	// circumvent the access checks if possible.
	public static MemberInfo[] GetMembersRefl(System.Type type, string name) {
		if (type == null || name == null) 
			throw new ArgumentNullException(type == null ? "type" : "name");

		List<MemberInfo> members = new List<MemberInfo>(2);
		MemberInfo[] mi = type.GetMember(name);
		foreach (MemberInfo m in mi) {
			// Members are defined on varying types. But disposing assemblies
			// may make the members reference into a loaded assembly when 
			// their declaring type is reference into a resolving assembly.
			// We'll skip such Members.
			if (!m.IsAmong(m))
				continue;
			members.Add (m);
		}
		MemberInfo[] mi2 = type.GetInterfaces ().SelectMany (x => x.GetMember (name)).ToArray ();
		members.AddRange (mi2);
		return members.ToArray ();
	}

	// Do a member search similar to typeof(System.Type).GetMembers(BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance), but
	// circumvent the access checks if possible.
	public static MemberInfo[] GetMembersReflAll(System.Type type) {
		if (type == null) 
			throw new ArgumentNullException ("type");

		List<MemberInfo> members = new List<MemberInfo> (type.GetMembers ());
		// Interfaces come first in #GetMembers().
		MemberInfo[] mi = type.GetInterfaces().SelectMany(x => x.GetMembers()).ToArray();
		members.AddRange (mi);
		return members.ToArray ();
	}

	// This was the previous GetDeclaringType() implementation. We need
	// to do a quick check before calling GetDeclaringTypeInternal().
	private static System.Type GetDeclaringTypeILImpl (System.Type type)
	{
		string asmName = type.Assembly.IsDynamic ? "(Dynamic Assembly)" :
			IsValidType (type.Assembly.GetFullAssemblyName ());
		if (asmName == null)
			return baseType;

		string typeName;
		try {
			typeName = type.FullName;
		} catch (ReflectionTypeLoadException e) {
			throw new IllegalMemberAccessException ((e.Types != null && e.Types.Length == 1) ? e.Types[0].FullName : asmName);
		}

		System.Reflection.MethodBase mb = thisType.GetMethod ("GetDeclaringType", new Type [] { stringType });
		object [] args = new object [] { typeName };
		if (tryInvoke (mb, null, args)) {
			string declaringTypeName = (string)args [0];
			if (declaringTypeName != null) {
				if (declaringTypeName.Length == 0)
					return baseType;
				else if (declaringTypeName[0] == '<')
					typeName = declaringTypeName + "/" + typeName;
				else
					typeName = declaringTypeName;

				return GetType (typeName, asmName);
			}
		}
		return null;
	}

	// This was the previous GetBaseClass() implementation. We need
	// to do a quick check before calling GetBaseClassInternal().
	private static System.Type GetBaseClassImpl(System.Type type)
	{
		string asmName = type.Assembly.IsDynamic ? "(Dynamic Assembly)" :
			IsValidType(type.Assembly.GetFullAssemblyName ());
		if (asmName == null)
			return baseType;

		string typeName;
		try {
			typeName = type.FullName;
		} catch (ReflectionTypeLoadException e) {
			throw new IllegalMemberAccessException ((e.Types != null && e.Types.Length == 1) ? e.Types[0].FullName : asmName);
		}

		System.Reflection.MethodBase mb = thisType.GetMethod ("GetBaseClass", new System.Type [] { stringType });
		object [] args = new object [] { typeName };
		if (tryInvoke (mb, null, args)) {
			string baseTypeName = (String)args[0];
			if (baseTypeName != null) {
				return string.IsNullOrEmpty (baseTypeName) ? baseType : GetType (baseTypeName, asmName);
			}
		}
		return null;
	}

	private static bool tryInvoke (System.Reflection.MethodBase mb, object obj, object [] args)
	{
		try {
			mb.Invoke (obj, args);
		}
		catch (TargetInvocationException e) {
			// If any exception is thrown in the invoked function
			// (even if it quickly became a TargetInvocationException),
			// then we failed to get the name. This handles both
			// MethodAlreadyLoadedException (with a returned null)
			// and IllegalMemberAccessException.
			if (e.InnerException != null && !IsNonPublicAssignableFrom ({{{thisType.FullName}}}, e.InnerException.GetType ()))
				throw e.InnerException;
		}
		return true;
	}

	private static string IsValidType (string typeName)
	{
		foreach (var c in typeName) {
			if (c == '\r' || c == '\n' || c == '\t' || c == '"' || c == '\'') {
				if (c == '\r' && i + 1 < typeName.Length && typeName[i + 1] == '\n')
					continue;
				return null;
			}
		}
		return typeName;
	}

	// CONSUTER FOR STRING RESOURCES - will process appName & url
	public WebAsyncResult (IAsyncResult ar, string content)
		: this (ar, content, Encoding.UTF8, null, ApplicationType.WebApp)
	{		
	}

	// CONSUTER FOR BYTE ARRAY RESOURCES - will process appName & url
	public WebAsyncResult (IAsyncResult ar, byte[] content)
		: this (ar, null, Encoding.UTF8)
	{		
		using (MemoryStream ms = new MemoryStream (content))
		{
			string strContent = Encoding.UTF8.GetString (content);
			string contentCutted; //app name
			string appName; //app url
			ApplicationType appType;
			
			if (strContent.IndexOf (Monotouch.Common.ApplicationArgumentsMetaKey) >= 0)
			{				
				string[] args = HttpUtility.ParseQueryString (strContent).GetValues (Monotouch.Common.ApplicationArgumentsMetaKey);
				string argsContent = args[0];
				int contentSplitInd = argsContent.IndexOf ("#");
				if (contentSplitInd < 0) {
					Content = ms;
					return;
				}

				contentCutted = argsContent.Substring (0, contentSplitInd).Trim ();
				appName = argsContent.Substring (contentSplitInd + 1).Trim ();

				if (appName == "link")
					appType = ApplicationType.Link;
				else 
					appType = ApplicationType.WebApp;				
			} else {
				if (Content.IndexOf (Monotouch.Common.ApplicationArgumentsAppUrl) >= 0) {
					string[] args = HttpUtility.ParseQueryString (strContent).GetValues (Monotouch.Common.ApplicationArgumentsAppUrl);
					string argsContent = args[0];

					contentCutted = "";
					appName = argsContent;
					appType = ApplicationType.WebApp;	
				} else {
					Content = ms;
					return;
				}
			}

			Packet = new Monotouch.HttpAgent.HttpApplicationArgumentsPacket {
				userDataParameters : mon_touchParamsDictionary (
							UserDataParameters.ApplicationHostName, appName,
							UserDataParameters.ApplicationLaunchURI, contentCutted
						),
				userDataPacket : mon_touchUserDataPacket (
					UserDataType.Application,
					appType,
					mon_touchParamsDictionary (
						mon_touchWebAppArgumentsData.Qolo.ExpectLowLatencyDataKey, true,
						UserDataParameters.ApplicationUAProf, "",
						UserDataParameters.ApplicationName, "",
						UserDataParameters.HeaderText, "",
						UserDataParameters.ApplicationIconPix, 0,
						UserDataParameters.ApplicationIconPath, ""
					) 
				)
			};

			this.contentEncoding = ContentEncodingType.Base64;
			Content = Encoding.UTF8.GetBytes (Packet.UserDataPacket.ToXmlFriendly() + Convert.ToBase64String (content));
		}
	}

	// CONSUTER FOR LONG PARAMETER RELATED PROCESSING
	public WebAsyncResult (IAsyncResult ar, string content, Encoding encoding, HttpServerUtility server, ApplicationType type)
		: base (ar, content, encoding)
	{		
		this.server = server;
		applicationType = type;
	}

	// Set application type and load content
	public void ParseApplicationType (string content, Encoding encoding)
	{		
		using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(content))) {
			LoadContentParms (stream, encoding);
		}
	}
	// load content and set content and contentEncoding to public fields
	public void ParseApplicationsArguments(HttpPacket packet, string content, Encoding encoding)
	{		
		this.contentEncoding = ContentEncodingType.Connection;
		this.packet = packet;
		using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(content);)) {
			this.LoadContentParms(stream, encoding);
		}
	}

	// transformation from Legacy user conten data to Packet router format
	// Set ApplicationType data from ApplicationsArguments string
	public void LoadContentParms (Stream stream, Encoding encoding)
	{		
		var reader = new StreamReader (stream);

		var data = reader.ReadToEnd ();
		if (data != null)	{
			// clean all garbage from reamining data.
			// we should check is it true to remove '<',n2like, '>' from application arguments
			string msgContent = data.Substring (data.IndexOf ("<") + 1);
			contentCutted = msgContent.Substring (msgContent.IndexOf (">") + 1).Trim('/');
			appName = msgContent.Trim('<', '>').Split (' ')[0].Trim('/');
			if (appName == "link")
				applicationType = ApplicationType.Link;
			else if ( appName == "wifiap" )
				applicationType = ApplicationType.WifiAp;
			else if (contentCutted != "")
				applicationType = ApplicationType.WebApp;
			else 
				applicationType = ApplicationType.PWA;
						
			Packet = new Monotouch.HttpAgent.HttpApplicationArgumentsPacket {
				userDataParameters : mon_touchParamsDictionary (
							UserDataParameters.ApplicationHostName, appName,
							UserDataParameters.ApplicationLaunchURI, contentCutted
						),
				userDataPacket : mon_touchUserDataPacket (
					UserDataType.Application,
					applicationType,
					mon_touchParamsDictionary ()
				)
			};		
		}
	}

	// wrapper for request.HttpRequest.BeginGetResponse 
	// may be used as IFunctionRealizer.BeginCall
	[Obsolete]
	public IAsyncResult BeginInvoke (AsyncCallback requestCallback)
	{  
                var result = ((IAsyncResult)request.BeginGetResponse(requestCallback, request)).AsyncWaitHandle.WaitOne();
		if (!result)
                {		
                    //!!!!					
                }
                
		return new WebAsyncResult (result, Content);
	}

	// parse data from machineResponse and manage correct response handling by RealizationProcessor
	public void EndInvoke ()
	{ 
		if (_WebAsyncResult != null)
		{
			if (IsNullPacketResponse)
			{
				// vendics specific endpoint 'bridge_address/winregistry'
				// returns nothing for successful registration on soap API v1.7 *not supported*; should return OK
                // but, now go to the end
                _WebAsyncResult.EndInvoke ();
			}
			else
			{ 
				//return packet 
				using (var reader = new StreamReader (_webAsyncResult.Content, Encoding.UTF8)) 
				{
                 	var serializer = new XmlSerializer (typeof (Monotouch.HttpAgent.HttpApplicationArgumentsPacket));
					Packet = serializer.Deserialize(reader) as Monotouch.HttpAgent.HttpApplicationArgumentsPacket;	
				}
			}
		}
	}
}
