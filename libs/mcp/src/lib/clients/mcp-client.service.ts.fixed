import { Injectable } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { Observable, catchError, firstValueFrom, of, throwError } from 'rxjs';
import { AxiosError, AxiosResponse } from 'axios';
import { MCPConfig } from '../interfaces/mcp-config.interface';
import { MCPServerConfig } from '../interfaces/mcp-server-config.interface';
import { HealthCheckResult } from '../interfaces/health-check-result.interface';
import { MCPResponse } from '../interfaces/mcp-response.interface';
import { MCPRequest } from '../interfaces/mcp-request.interface';
import { MCPInvocationLoggingService } from '../services/mcp-invocation-logging.service';
import { LogLevel } from '../enums/log-level.enum';
import { ErrorCodes } from '../enums/error-codes.enum';
import { MCPError } from '../errors/mcp.error';
import { ServerHealthMonitoringService } from '../services/server-health-monitoring.service';
import { ServerHealthStatus } from '../interfaces/server-health-status.interface';

@Injectable()
export class MCPClientService {
  private healthCheckInterval: NodeJS.Timeout | null = null;
  
  constructor(
    private readonly httpService: HttpService,
    private readonly loggingService: MCPInvocationLoggingService,
    private readonly healthMonitoring: ServerHealthMonitoringService,
    private readonly config: MCPConfig
  ) {
    this.setupHealthChecks();
  }
  
  private setupHealthChecks(): void {
    try {
      if (this.config?.global.healthMonitoring && this.config?.global.healthMonitoring.enabled) {
        const interval = this.config.global.healthMonitoring.interval || 60000;
        
        // Clear any existing interval
        if (this.healthCheckInterval) {
          clearInterval(this.healthCheckInterval);
        }
        
        // Set up new interval
        this.healthCheckInterval = setInterval(() => {
          this.checkAllServersHealth();
        }, interval);
        
        this.loggingService.log(
          LogLevel.INFO,
          `Health monitoring enabled with interval: ${interval}ms`
        );
      }
    } catch (error) {
      this.loggingService.error(
        'Failed to setup health checks',
        error
      );
    }
  }
  
  private async connectToServer(config: MCPServerConfig): Promise<void> {
    try {
      const healthCheck = await this.checkServerHealth(config);
      if (healthCheck && healthCheck.status === 'healthy') {
        this.loggingService.log(
          LogLevel.INFO,
          `Successfully connected to server: ${config.name}`
        );
      } else {
        throw new MCPError(
          ErrorCodes.SERVER_UNHEALTHY,
          `Server ${config.name} is unhealthy: ${healthCheck?.details || 'No details available'}`
        );
      }
    } catch (error) {
      this.loggingService.error(
        `Failed to connect to server: ${config.name}`,
        error
      );
      throw error;
    }
  }
  
  async checkServerHealth(config: MCPServerConfig): Promise<HealthCheckResult | null> {
    try {
      const url = `${config.url}/health`;
      
      this.loggingService.log(
        LogLevel.DEBUG,
        `Checking health for server: ${config.name} at ${url}`
      );
      
      const response = await firstValueFrom(
        this.httpService.get<HealthCheckResult>(url).pipe(
          catchError((error: AxiosError) => {
            this.loggingService.error(
              `Health check failed for server: ${config.name}`,
              error
            );
            return of({
              data: {
                status: 'unhealthy',
                details: error.message,
              } as HealthCheckResult,
            } as AxiosResponse);
          })
        )
      );
      
      const result = response.data;
      
      // Update server health status
      this.healthMonitoring.updateServerHealth(config.name, {
        timestamp: new Date().toISOString(),
        status: result.status === 'healthy' ? 'healthy' : 'unhealthy',
        details: result.details,
        latency: result.latency || 0,
      });
      
      return result;
    } catch (error) {
      this.loggingService.error(
        `Error during health check for server: ${config.name}`,
        error
      );
      
      // Update server health as unhealthy
      this.healthMonitoring.updateServerHealth(config.name, {
        timestamp: new Date().toISOString(),
        status: 'unhealthy',
        details: error instanceof Error ? error.message : 'Unknown error',
        latency: 0,
      });
      
      return null;
    }
  }
  
  async checkAllServersHealth(): Promise<Record<string, ServerHealthStatus>> {
    const results: Record<string, ServerHealthStatus> = {};
    
    if (!this.config || !this.config.servers) {
      return results;
    }
    
    for (const server of this.config.servers) {
      if (server.enabled) {
        try {
          const health = await this.checkServerHealth(server);
          results[server.name] = this.healthMonitoring.getServerHealth(server.name);
        } catch (error) {
          this.loggingService.error(
            `Failed to check health for server: ${server.name}`,
            error
          );
        }
      }
    }
    
    return results;
  }
  
  async invokeServer(
    serverName: string,
    request: MCPRequest
  ): Promise<MCPResponse> {
    const server = this.getServerConfig(serverName);
    if (!server) {
      throw new MCPError(
        ErrorCodes.SERVER_NOT_FOUND,
        `Server not found: ${serverName}`
      );
    }
    
    if (!server.enabled) {
      throw new MCPError(
        ErrorCodes.SERVER_DISABLED,
        `Server is disabled: ${serverName}`
      );
    }
    
    // Get current health status
    const health = this.healthMonitoring.getServerHealth(serverName);
    if (health && health.status === 'unhealthy') {
      throw new MCPError(
        ErrorCodes.SERVER_UNHEALTHY,
        `Server is unhealthy: ${serverName} - ${health.details}`
      );
    }
    
    const url = `${server.url}/invoke`;
    const startTime = Date.now();
    
    try {
      this.loggingService.logRequest(serverName, request);
      
      const response = await firstValueFrom(
        this.httpService.post<MCPResponse>(url, request).pipe(
          catchError((error: AxiosError) => {
            const mcpError = new MCPError(
              ErrorCodes.SERVER_INVOCATION_FAILED,
              `Failed to invoke server: ${serverName}`,
              error
            );
            
            this.loggingService.logError(serverName, request, mcpError);
            this.healthMonitoring.recordFailure(serverName);
            
            return throwError(() => mcpError);
          })
        )
      );
      
      const endTime = Date.now();
      const latency = endTime - startTime;
      
      this.loggingService.logResponse(serverName, request, response.data, latency);
      this.healthMonitoring.recordSuccess(serverName, latency);
      
      return response.data;
    } catch (error) {
      throw error;
    }
  }
  
  getServerConfig(serverName: string): MCPServerConfig | undefined {
    return this.config?.servers?.find((s) => s.name === serverName);
  }
  
  getServerHealthStatus(serverName: string): ServerHealthStatus | null {
    return this.healthMonitoring.getServerHealth(serverName);
  }
  
  getAllServersHealthStatus(): Record<string, ServerHealthStatus> {
    return this.healthMonitoring.getAllServersHealth();
  }
  
  getEnabledServers(): MCPServerConfig[] {
    return this.config?.servers?.filter((server) => server.enabled) || [];
  }
}
