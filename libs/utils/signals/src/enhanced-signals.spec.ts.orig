/**
 * @fileoverview Unit tests for the enhanced signals implementation
 *
 * This file is part of the Dulce de Saigon F&B Data Platform.
 * Contains test cases for verifying the enhanced signal functionality.
 *
 * @author Dulce de Saigon Engineering
 * @copyright Copyright (c) 2025 Dulce de Saigon
 * @license MIT
 */

import {
  createSignal,
  useSignal,
  type SignalValue,
  type UnwrapSignal,
} from '../enhanced-index';
import { renderHook, act } from '@testing-library/react';

describe('Enhanced Signals Library', () => {
  describe('createSignal', () => {
    it('should create a signal with the initial value', () => {
      const count = createSignal(0);
      expect(count.get()).toBe(0);
    });

    it('should update the signal value when set is called', () => {
      const count = createSignal(0);
      count.set(5);
      expect(count.get()).toBe(5);
    });

    it('should support functional updates', () => {
      const count = createSignal(5);
      count.set(prev => prev + 10);
      expect(count.get()).toBe(15);
    });

    it('should skip update when values are equal with deepEqual option', () => {
      const obj = { a: 1, b: 2 };
      const objSignal = createSignal(obj, { deepEqual: true });

      const setMethodSpy = jest.fn();
      const originalSet = objSignal.set;
      objSignal.set = (value: typeof obj | ((prev: typeof obj) => typeof obj)) => {
        const resolvedValue = typeof value === 'function' ? value(objSignal.get()) : value;
        setMethodSpy(resolvedValue);
        originalSet(value);
      };

      objSignal.set({ ...obj });

      expect(objSignal.get()).toEqual(obj);
      expect(setMethodSpy).toHaveBeenCalledTimes(1);

      objSignal.set({ a: 1, b: 3 });
      expect(objSignal.get()).toEqual({ a: 1, b: 3 });
      expect(setMethodSpy).toHaveBeenCalledTimes(2);
    });

    it('should support custom equality functions', () => {
      const customEquals = (a: { id: number }, b: { id: number }) => {
        return a.id === b.id;
      };

      const objSignal = createSignal({ id: 1, value: 'test' }, {
        equals: customEquals,
      });

      objSignal.set({ id: 1, value: 'changed' });
      expect(objSignal.get()).toEqual({ id: 1, value: 'test' });

      objSignal.set({ id: 2, value: 'test' });
      expect(objSignal.get()).toEqual({ id: 2, value: 'test' });
    });
  });

  describe('useSignal React Hook', () => {
    it('should return the current signal value and a setter', () => {
      const countSignal = createSignal(0);

      const { result } = renderHook(() => useSignal(countSignal));

      expect(result.current[0]).toBe(0);
      expect(typeof result.current[1]).toBe('function');
    });

    it('should update the component when the signal changes', () => {
      const countSignal = createSignal(0);

      const { result } = renderHook(() => useSignal(countSignal));

      act(() => {
        countSignal.set(5);
      });

      expect(result.current[0]).toBe(5);
    });

    it('should update the signal when the setter is called', () => {
      const countSignal = createSignal(0);

      const { result } = renderHook(() => useSignal(countSignal));

      act(() => {
        result.current[1](5);
      });

      expect(countSignal.get()).toBe(5);
    });

    it('should support functional updates in the hook', () => {
      const countSignal = createSignal(5);

      const { result } = renderHook(() => useSignal(countSignal));

      act(() => {
        result.current[1](prev => prev + 10);
      });

      expect(countSignal.get()).toBe(15);
    });

    it('should not cause unnecessary re-renders with memoized setter', () => {
      const countSignal = createSignal(5);

      const { result, rerender } = renderHook(() => useSignal(countSignal));
      const initialSetter = result.current[1];

      rerender();

      expect(result.current[1]).toBe(initialSetter);
    });
  });

  describe('TypeScript Type Safety', () => {
    it('should correctly infer signal types', () => {
      const numSignal = createSignal(42);
      const strSignal = createSignal('hello');
      const objSignal = createSignal({ foo: 'bar' });

      type NumType = SignalValue<typeof numSignal>;
      type StrType = SignalValue<typeof strSignal>;
      type ObjType = SignalValue<typeof objSignal>;

      const num: NumType = 100;
      const str: StrType = 'world';
      const obj: ObjType = { foo: 'baz' };

      expect(typeof num).toBe('number');
      expect(typeof str).toBe('string');
      expect(typeof obj).toBe('object');
    });

    it('should support UnwrapSignal utility type', () => {
      interface TestObject {
        id: number;
        name: string;
      }

      const objSignal = createSignal<TestObject>({ id: 1, name: 'test' });

      type UnwrappedType = UnwrapSignal<typeof objSignal>;

      const unwrapped: UnwrappedType = { id: 2, name: 'unwrapped' };

      expect(unwrapped.id).toBe(2);
      expect(unwrapped.name).toBe('unwrapped');
    });
  });
});
